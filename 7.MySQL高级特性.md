## MySQL高级特性

+ 分区表
    + 分区表种类
        + RANGE分区表 : 范围分区，LESS THAN
        + LIST分区表  : 精准分区，IN
        + HASH分区表  : 平均分布
        + Key分区表   : 类似HASH分区表
        + 子分区表    : 在上述分区表的基础上再建立分区表
    
    + 大量数据时的分表策略
        + 全量扫描数据，不要任何索引
        + 索引数据，并分离热点
    
    + 分区表的问题
        + NULL值会使分区过滤无效
        + 分区列和索引列不匹配
        + 选择分区的成本可能很高
        + 打开并锁住所有底层表的成本可能很高
        + 维护分区的成本可能很高

    + 分区表查询优化
        + 在where查询种带入分区列，即使多余也要带上
        + 需要过滤分区必须使用分区列

    + 使用explain partition可以观察优化器是否执行了分区过滤

+ 视图
    > 视图是一个虚拟表，其内容由查询定义。不存在于磁盘上，包含与表相同的数据
    + 视图的作用
        + 提高查询重用性
        + 重构数据库，不对数据库产生影响
        + 提高安全性能
        + 数据清晰化，想要什么数据就创建什么类型的视图
        + 会占用大量资源

    + 视图的执行方法
        + 合并算法 : MySQL优化器会将带有视图查询SQL和查询SQL进行合并，然后向底层发起查询
        + 临时表算法 : MySQL服务器会将视图数据保存在临时表中，任何视图查询都会先向底层发起查询然后缓存到服务器的临时表中
        + 如果视图中包含group by，distinct，聚合函数，UNION，子查询，只要无法在原表记录和视图记录中建立一一映射关系的场景，都会采用临时表算法
        
+ 外键约束
    + 外键使用是有一定成本的
    + 外键在某些场景可以提升性能，比如保持两个相关表数据一致性
    + 外键一般用于同步数据一致性，而如果是做约束作用，可能触发器会更适合

+ MySQL内部存储代码
    + 优点
        + 它在服务器内部执行，可以免去宽带和网络延迟
        + 是一种代码重用，可以规范一致，安全
        + 简化代码维护和版本更新
        + 提供更细粒度的权限控制
        + 服务器可以缓存存储过程的执行计划，对于需要反复调用的过程，会大大降低消耗
    + 缺点
        + 效率较差
        + 可能会给应用程序代码的部署带来额外的复杂性
        + 会给服务器增加额外的压力
        + MySQL没有控制存储过程资源消耗的选项
    + 存储代码应该是一种帮助应用隐藏复杂性，使应用开发更简单的方法

    + 语法
        ```
        DROP PROCEDURE IF EXISTS insert_many_rows;

        delimiter //
    
        CREATE PROCEDURE insert_many_rows (IN loops INT)
        BEGIN 
            DECLARE v1 INT;
            SET v1=loops;
            WHILE v1 > 0 DO 
                INSERT INTO table values(1,1,1,1);
                SET v1 = v1 - 1;
            END WHILE;
        END;
        //
    
        delimiter ;
        存储过程对比客户端插入会快很多
        ```  

+ 触发器
    + 对于一个表的每个事件，最多只能定义一个触发器。
    + MySQL只支持基于行的触发
    + 触发器的问题很难排查，如果失败，那么原来的SQL语句也会失败

+ MySQL时间
    + 类似于Linux定时器

+ 字符集和校对
    + 查看系统字符集
        + show variables like '%char%';
    
+ 全文索引
    ```
    MySQL存储引擎支持最小最大长度的全文索引搜索，修改MySQL配置文件可以修改这两个参数。 
    查看MySQL引擎支持的最小最长全文索引搜索长度 : show variables like '%ft%';
    ```
    + 自然语言的全文索引
        ```
        自然语言搜索引擎将计算搜索目标与每一个文档对象的相关度。
        相关度基于目标在文档中出现的比率，在文档中出现越少相关度越高，如果比率超过50%，那么搜索引擎将会过滤目标不再搜索。
        其中文档指的是全文索引，比如a列和b列组成全文索引，那么a+b就是文档

        语法 : select * from table match(target_1,target_2...) against('context')；
        match()函数将返回关键词匹配的相关度，使用order by处理会采用文件排序
        ```

    + BOOLEAN全文索引
        ```
        布尔全文索引的符号含义
        target      包含target的行排名会更靠前
        ~target     包含target的排名会更靠后
        +target     必须包含target
        -target     可以不包含target
        target*     包含以target开头的单词的行，排名更靠前
        ```
        
        + 使用全文索引不能查找太常见的词语，如果关键词太常见LIKE操作反而更快
    
    + 全文索引优化策略
        + 定期optimize table 来减少碎片
        + 如果应用是IO密集型，定期重建全文索引
        + 为全文索引加大索引缓存，为全文索引设立单独的键缓存

+ 查询缓存
    > 默认是关闭的
    + 查询缓存不被命中的情况
        + 任何字符，语句，空格，注释上的不同，都不会命中
        + 查询语句中包含不确定数据时，不会命中
        + 用户自定义函数，存储函数，用户变量，临时表等，不会命中
        + MySQL不会将不被命中的查询语句的结果存入缓存
        + 被事务修改过的表，其表的查询缓存都将失效。长时间运行的事务，会大大降低查询缓存命中率

    + 需要查询缓存的情况
        + 系统做大量很大消耗的查询，如联表分页排序查询，count()统计查询
        + 查询占多，更新和插入占少数的表
        + 如果缓存结果在失效前没有被任何查询使用，那就是浪费时间和内存，因此频繁更新的表不适合设置查询缓存

        
   
