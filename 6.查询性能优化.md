## 查询性能优化
+ 为什么查询速度会慢？
    ```
    如果把查询当作一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定时间。
    如果要优化查询，实际上要优化子任务，要么消除一些子任务，要么减少子任务的执行次数，要么让子任务运行的更快。
    查询的生命周期大致可以按照顺序来看:客户端-服务器-服务器上解析-生成执行计划-执行-返回结果给客户端。
    在完成这些任务时，查询需要在不同的地方花费时间，包括网络，cpu计算，生成统计信息和执行计划，锁等待等操作。尤其是向底层存储引擎检索数据的调用操作
    ```

+ 慢查询基础 : 优化数据访问
    ```
    查询性能低下的最根本原因就是访问的数据太多。大部分性能低的查询都可以通过减少访问数据量的方式优化。对于低效查询，可以从下面两方面检查:
        1.确认查询语句是否在检索大量超过需要的数据
        2.确认MySQL服务器层是否在分析大量超过需要的数据行
    ```
    + 是否向数据库请求了不需要的数据？下面是一些典型的错误案例
        + 查询不需要的记录 : 解决方法是配合Limit只取需要的数据
        + 多表关联时返回全部列
        + 总是取出全部列 : 严禁使用select * 的写法，只取需要的列
        + 在程序中不使用缓存将频繁使用的查询数据缓存起来，重复调用这些查询语句
    
    + MySQL是否在扫描额外的记录
        ```
        对于MySQL，最简单衡量擦汗寻开销的三个指标
            1.响应时间
            2.扫描的行数
            3.返回的行数
        这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法
        ```
        + 响应时间 : 服务时间和排队时间之和
            + 服务时间 : 数据库处理这个查询真正花了多长时间
            + 排队时间 : 各种等待处理查询的时间
        + 扫描的行数和返回的行数
            + 理想情况下扫描的行数和返回的行数应该是相同的。通常扫描行数和返回的行数比例在 1:1到10:1之间
        + 扫描的行数和访问类型
            > 使用explain关键字可以分析出查询语句以何种方式访问数据，扫描了多少行的数据才取得结果等信息。
            + 如果查询没有找到合适的访问类型，那么通常最好是增加一个合适的索引
            + 一般MySQL能使用如下三种方式应用where条件，从好到坏依次为:
                + 在索引中使用where过滤，这是在存储引擎层完成
                + 使用索引覆盖扫描(Extra中出现Using Index)，这是在MySQL服务器层完成，无需回表
                + 从数据表中返回数据，然后再过滤(Extra中出现Using Where)，这是在MySQL服务器层完成
            + 通过使用explain和count(*)可以算出扫描行和返回行的比例
            + 如果发现扫描行和返回行比例非常大，可以尝试下面的技巧去优化:
                + 使用索引覆盖
                + 该表库表结构，例如汇总表等
                + 重写查询语句

+ 重构查询的方式
    + 一个复杂查询还是多个简单查询？
    + 切分查询
        ```
        有时候我们需要对一个大查询切分成小查询，每个查询功能一样，只完成一小部分。这样可以大幅缓解MySQL服务器压力，让应用受到MySQL服务器的影响最小化
        例如 : 删除旧数据就是一个很好的例子。
            DELETE from table WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH);
            
            rows_affected = 0
            do{
                rows_affected = do_query(
                    "DELETE from table WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH) LIMIT 10000")
            }while rows_affected > 0
        ```
    + 分解关联查询
        ```
        很多高性能应用会对关联查询进行分解:
            SELECT * FROM table
                JOIN table_1 ON table_1.id = table.id
                JOIN table_2 ON table_2.num = table.num
                WHERE table.title = 'mysql';
        分解为:
            SELECT * FROM table WHERE table.title = 'mysql';
            SELECT * FROM table_1 WHERE table_1.id = 123;
            SELECT * FROM table_2 WHERE table_2.num in (1,2,3,4,5);
        ```
        + 分解关联查询的优势有:
            + 让缓存的效率更高
            + 将查询分解后，执行单个查询可以减少锁的竞争
            + 在应用层做关联，可以更容易对数据库拆分，更容易做到高性能和可拓展
            + 查询本身的效率可能提升
            + 减少冗余记录的查询
